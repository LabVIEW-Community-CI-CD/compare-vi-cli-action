name: Validate

on:
  pull_request:
    branches: [ main, 'release/*' ]
  push:
    branches: [ main, 'release/*' ]
  workflow_dispatch:
    inputs:
      summary-verbose:
        description: 'Emit verbose fixture summary (sets SUMMARY_VERBOSE=true)'
        required: false
        default: 'false'

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Install actionlint
        run: |
          mkdir -p ./bin
          curl -sSL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash | bash -s -- latest ./bin

      - name: Run actionlint
        run: |
          ./bin/actionlint -color

      - name: YAML fixer (dry-run)
        shell: bash
        run: |
          set -euo pipefail
          python3 --version || true
          python3 tools/workflows/update_workflows.py --check .github/workflows/pester-selfhosted.yml || {
            echo "::error::Workflow requires ruamel.yaml fixes (run updater locally with --write)"; exit 1; }

      - name: Lint unanchored dot-sourcing (non-blocking)
        shell: pwsh
        continue-on-error: true
        run: |
          pwsh -NonInteractive -File tools/Lint-DotSourcing.ps1 -WarnOnly

      - name: Lint param-first (warn-only)
        shell: pwsh
        continue-on-error: true
        run: pwsh -NonInteractive -File tools/Lint-ParamFirst.ps1 -WarnOnly

      - name: Lint param-first (strict on main)
        if: ${{ github.ref == 'refs/heads/main' }}
        shell: pwsh
        run: pwsh -NonInteractive -File tools/Lint-ParamFirst.ps1

      - name: Lint inline-if in format (-f)
        shell: pwsh
        run: pwsh -NonInteractive -File tools/Lint-InlineIfInFormat.ps1

      - name: Install markdownlint-cli
        run: |
          npm install -g markdownlint-cli

      - name: Run markdownlint
        run: |
          markdownlint "**/*.md" --ignore node_modules

      - name: Local markdown link check (intra-repo)
        shell: pwsh
        run: |
          # Simple intra-repo link checker: scans markdown for (./...) links and verifies files exist.
          $ErrorActionPreference = 'Stop'
          $mdFiles = Get-ChildItem -Path . -Recurse -Include *.md
          $errors = @()
          foreach ($file in $mdFiles) {
            $text = Get-Content -LiteralPath $file.FullName -Raw
            $matches = [regex]::Matches($text, '\]\((\.\/?[^)#\s]+)\)')
            foreach ($m in $matches) {
              $rel = $m.Groups[1].Value
              if ($rel -like 'http*' -or $rel -like '#*') { continue }
              # Strip anchors like file.md#section
              $pathOnly = $rel.Split('#')[0]
              $target = Join-Path $file.DirectoryName $pathOnly
              if (-not (Test-Path -LiteralPath $target)) {
                $errors += "[$($file.FullName)] broken link -> $rel (resolved: $target)"
              }
            }
          }
          if ($errors.Count -gt 0) {
            Write-Host 'Broken intra-repo links detected:'
            $errors | ForEach-Object { Write-Host " - $_" }
            exit 2
          } else {
            Write-Host 'Intra-repo markdown links OK.'
          }

      - name: Repo hygiene (warn-only)
        shell: pwsh
        continue-on-error: true
        run: pwsh -NonInteractive -File tools/Check-RepoHygiene.ps1 -WarnOnly

      - name: Repo hygiene (strict on protected branches)
        if: ${{ github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/') }}
        shell: pwsh
        run: pwsh -NonInteractive -File tools/Check-RepoHygiene.ps1

      - name: Append required checks (branch rules hint)
        if: always()
        shell: pwsh
        run: |
          $lines = @(
            '### Required checks (copy for branch protections)',
            '- Pester (self-hosted) / preflight',
            '- Pester (self-hosted) / pester (dispatcher|fixtures|schema|comparevi|loop|runbook|orchestrator)',
            '- Fixture Drift Validation / Fixture Drift (Windows)',
            '- VI Binary Handling Gate / vi-binary-check',
            '- Validate / lint',
            '- markdownlint / lint'
          ) -join "`n"
          $lines | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          $doc = 'docs/BRANCH_RULES.md'
          if (Test-Path $doc) {
            "See: ./$doc" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          } else {
            'Branch rules guide: docs/BRANCH_RULES.md (coming soon in issue #60)' | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }

      - name: Labels sync (warning, RC)
        if: startsWith(github.ref, 'refs/heads/release/') || github.ref_name == 'main'
        shell: pwsh
        continue-on-error: true
        run: |
          $labelsFile = '.github/labels.yml'
          if (-not (Test-Path -LiteralPath $labelsFile)) { Write-Host '::notice::.github/labels.yml not found'; exit 0 }
          try {
            $yaml = Get-Content -LiteralPath $labelsFile -Raw
            $names = @([regex]::Matches($yaml,'(?m)^\s*-\s*name:\s*(.+?)\s*$') | ForEach-Object { $_.Groups[1].Value.Trim() })
          } catch { $names = @() }
          $api = "https://api.github.com/repos/${{ github.repository }}/labels?per_page=100"
          $hdr = @{ Authorization = "Bearer $env:GITHUB_TOKEN"; Accept='application/vnd.github+json'; 'X-GitHub-Api-Version'='2022-11-28' }
          $existing = @()
          try { $resp = Invoke-RestMethod -Method Get -Uri $api -Headers $hdr; $existing = @($resp | ForEach-Object { $_.name }) } catch {}
          $missing = @($names | Where-Object { $_ -and ($existing -notcontains $_) })
          if ($missing.Count -gt 0) {
            foreach ($m in $missing) { Write-Host ("::warning::Missing label: {0}" -f $m) }
          } else {
            Write-Host 'Labels OK (RC)'
          }

  fixtures:
    runs-on: [self-hosted, Windows, X64]
    env:
      FAIL_ON_NEW_STRUCTURAL: 'false' # toggle to 'true' to fail job on new structural fixture issues
      SUMMARY_VERBOSE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.summary-verbose || 'false' }}
    steps:
      - uses: actions/checkout@v5
      - name: Run fixture validator (JSON)
        shell: pwsh
        continue-on-error: true
        run: |
          $ErrorActionPreference = 'Stop'
          pwsh -NonInteractive -File tools/Validate-Fixtures.ps1 -Json -MinBytes 32 > fixture-validation.json
          $exit = $LASTEXITCODE
          if ($exit -ne 0) { Write-Host "::warning::Fixture validator exit code: $exit (non-blocking)" }
          $data = Get-Content fixture-validation.json -Raw | ConvertFrom-Json
          if (-not $data.ok) { Write-Host 'Fixture validation issues detected. (Non-fatal: continuing for now)' }
      - name: Restore previous fixture validation snapshot (cache)
        id: restore_prev_fixture_validation
        uses: actions/cache/restore@v4
        with:
          path: fixture-validation-prev.json
          key: fixture-validation-${{ github.sha }}
          restore-keys: |
            fixture-validation-
      - name: Compute delta vs previous snapshot
        if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true'
        shell: pwsh
        run: |
          Write-Host 'Previous snapshot restored. Computing delta.'
          pwsh -NonInteractive -File tools/Diff-FixtureValidationJson.ps1 -Baseline fixture-validation-prev.json -Current fixture-validation.json -FailOnNewStructuralIssue > fixture-validation-delta.json
          if ($LASTEXITCODE -eq 3) {
            Write-Host 'New structural fixture issues detected (delta willFail=true).'
            if ($env:FAIL_ON_NEW_STRUCTURAL -eq 'true') {
              Write-Error 'Failing job due to FAIL_ON_NEW_STRUCTURAL=true'
              exit 3
            } else {
              Write-Host 'FAIL_ON_NEW_STRUCTURAL=false -> continuing without failing.'
            }
          }
      - name: Validate delta JSON schema (basic)
        if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
        shell: pwsh
        run: |
          pwsh -NonInteractive -File tools/Test-FixtureValidationDeltaSchema.ps1 -DeltaJsonPath fixture-validation-delta.json
      - name: Lite schema validate (delta)
        if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
        shell: pwsh
        run: |
          pwsh -NonInteractive -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath fixture-validation-delta.json -SchemaPath docs/schemas/fixture-validation-delta-v1.schema.json
      - name: Upload fixture validation delta JSON
        if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
        uses: actions/upload-artifact@v4
        with:
          name: validate-fixture-validation-delta-json
          path: fixture-validation-delta.json
      - name: Upload fixture validation JSON
        uses: actions/upload-artifact@v4
        with:
          name: validate-fixture-validation-json
          path: fixture-validation.json
      - name: Lite schema validate (snapshot)
        shell: pwsh
        continue-on-error: true
        run: |
          if (Test-Path fixture-validation.json) {
            try {
              pwsh -NonInteractive -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath fixture-validation.json -SchemaPath docs/schemas/fixture-manifest-v1.schema.json
              if ($LASTEXITCODE -ne 0) { Write-Host "::notice::Snapshot schema-lite returned $LASTEXITCODE (non-blocking)" }
            } catch { Write-Host '::notice::Snapshot schema-lite skipped or failed (non-fatal).' }
          }
      - name: Append fixture summary
        shell: pwsh
        run: pwsh -NonInteractive -File tools/Write-FixtureValidationSummary.ps1 -ValidationJson fixture-validation.json -DeltaJson fixture-validation-delta.json
      - name: Write fixture summary file
        if: always()
        shell: pwsh
        run: pwsh -NonInteractive -File tools/Write-FixtureValidationSummary.ps1 -ValidationJson fixture-validation.json -DeltaJson fixture-validation-delta.json -SummaryPath fixture-summary.md
      - name: Upload fixture summary artifact
        if: always() && hashFiles('fixture-summary.md') != ''
        uses: actions/upload-artifact@v4
        with:
          name: fixture-validation-summary
          path: fixture-summary.md
      - name: Save current snapshot to cache
        uses: actions/cache/save@v4
        with:
          path: fixture-validation.json
          key: fixture-validation-${{ github.sha }}
      - name: Copy snapshot for next run reference
        shell: pwsh
        run: Copy-Item -LiteralPath fixture-validation.json -Destination fixture-validation-prev.json -Force

  session-index:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Install Pester v5 (non-interactive)
        shell: pwsh
        run: |
          try { Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted -ErrorAction SilentlyContinue } catch {}
          Install-Module -Name Pester -MinimumVersion 5.0.0 -Force -Scope CurrentUser -SkipPublisherCheck -Confirm:$false

      - name: Run dispatcher smoke to produce session index
        shell: pwsh
        run: |
          $res = Join-Path $env:RUNNER_TEMP 'sessionindex'
          New-Item -ItemType Directory -Force -Path $res | Out-Null
          ./tools/Quick-DispatcherSmoke.ps1 -ResultsPath $res -PreferWorkspace

      - name: Validate session index schema (schema-lite)
        shell: pwsh
        run: |
          $json = Join-Path $env:RUNNER_TEMP 'sessionindex' 'session-index.json'
          if (-not (Test-Path $json)) { Write-Error "session-index.json not found at $json"; exit 2 }
          pwsh -NonInteractive -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath $json -SchemaPath docs/schemas/session-index-v1.schema.json

      - name: Upload session index artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validate-session-index
          path: ${{ runner.temp }}/sessionindex/session-index.json
          if-no-files-found: warn
