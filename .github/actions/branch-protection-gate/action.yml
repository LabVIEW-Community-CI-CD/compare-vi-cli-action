name: "Branch Protection Gate"
description: "Fail fast when required status checks differ from expected on a target branch"
inputs:
  branch:
    description: "Branch to check (defaults to PR base or ref_name)"
    required: false
    default: ''
  required-checks:
    description: |
      Newline-separated list of required status checks (contexts)
      If empty, uses the repo's standard set from docs/BRANCH_RULES.md.
    required: false
    default: |
      Pester (self-hosted) / preflight
      Pester (self-hosted) / pester (dispatcher)
      Pester (self-hosted) / pester (fixtures)
      Pester (self-hosted) / pester (schema)
      Pester (self-hosted) / pester (comparevi)
      Pester (self-hosted) / pester (loop)
      Pester (self-hosted) / pester (runbook)
      Pester (self-hosted) / pester (orchestrator)
      Fixture Drift Validation / Fixture Drift (Windows)
      VI Binary Handling Gate / vi-binary-check
      Validate / lint
      markdownlint / lint
  strict:
    description: "Fail when mismatch is detected (defaults true)"
    required: false
    default: 'true'
  fail-on-no-access:
    description: "When true and strict=true, fail if branch protection cannot be read (e.g., missing admin PAT)"
    required: false
    default: 'true'
runs:
  using: composite
  steps:
    - name: Check branch protection
      shell: pwsh
      env:
        GH_REPOSITORY: ${{ github.repository }}
        GH_REF_NAME: ${{ github.ref_name }}
        GH_EVENT_NAME: ${{ github.event_name }}
        GH_EVENT_PATH: ${{ github.event_path }}
        INPUT_BRANCH: ${{ inputs.branch }}
        STRICT: ${{ inputs.strict }}
        FAIL_NO_ACCESS: ${{ inputs['fail-on-no-access'] }}
        REQUIRED_CHECKS: ${{ inputs.required-checks }}
        # Prefer a PAT with admin rights; fallback to GITHUB_TOKEN (may lack admin perms)
        GATE_PAT: ${{ secrets.XCLI_PAT }}
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        $ErrorActionPreference = 'Stop'
        function Get-TargetBranch {
          if ($env:INPUT_BRANCH) { return $env:INPUT_BRANCH }
          if ($env:GH_EVENT_NAME -eq 'pull_request') {
            try { $evt = Get-Content -Raw -LiteralPath $env:GH_EVENT_PATH | ConvertFrom-Json; if ($evt.base.ref) { return [string]$evt.base.ref } } catch {}
          }
          return $env:GH_REF_NAME
        }
        function Get-DocsUrl($repo, $branch) {
          if ($env:GH_EVENT_NAME -eq 'pull_request') {
            try {
              $evt = Get-Content -Raw -LiteralPath $env:GH_EVENT_PATH | ConvertFrom-Json
              if ($evt.head.ref -and $evt.head.repo.full_name) {
                return ('https://github.com/{0}/blob/{1}/docs/BRANCH_RULES.md' -f $evt.head.repo.full_name, $evt.head.ref)
              }
            } catch {}
          }
          return ('https://github.com/{0}/blob/{1}/docs/BRANCH_RULES.md' -f $repo, $branch)
        }
        function Get-BranchSpecificDocsUrl($repo, $branch) {
          $safeRef = $branch
          if ($env:GH_EVENT_NAME -eq 'pull_request') {
            try {
              $evt = Get-Content -Raw -LiteralPath $env:GH_EVENT_PATH | ConvertFrom-Json
              if ($evt.head.ref -and $evt.head.repo.full_name) {
                return ('https://github.com/{0}/blob/{1}/docs/branch-rules/{2}.md' -f $evt.head.repo.full_name, $evt.head.ref, $evt.base.ref)
              }
            } catch {}
          }
          return ('https://github.com/{0}/blob/{1}/docs/branch-rules/{2}.md' -f $repo, $branch, $branch)
        }
        $branch = Get-TargetBranch
        $repo = $env:GH_REPOSITORY
        $owner,$name = $repo.Split('/')
        $token = if ($env:GATE_PAT) { $env:GATE_PAT } else { $env:GITHUB_TOKEN }
        $hdr = @{ Authorization = "Bearer $token"; Accept = 'application/vnd.github+json'; 'X-GitHub-Api-Version'='2022-11-28' }
        $url = "https://api.github.com/repos/$owner/$name/branches/$branch/protection/required_status_checks"
        $ok = $true; $json = $null
        try {
          $json = Invoke-RestMethod -Method Get -Uri $url -Headers $hdr -ErrorAction Stop
        } catch {
          $ok = $false
          $msg = $_.Exception.Message
          $docsUrl = Get-DocsUrl -repo $repo -branch $branch
          $branchDocUrl = Get-BranchSpecificDocsUrl -repo $repo -branch $branch
          $settingsUrl = ('https://github.com/{0}/settings/branches' -f $repo)
          $lines = @('### Branch Protection Gate (notice-only)','')
          $lines += "- Repo: $repo  Branch: $branch"
          $lines += ('- Status: could not read protection via API. Reason: ' + $msg)
          $lines += ''
          $lines += '- Expected required checks (see docs for details):'
          foreach (($env:REQUIRED_CHECKS -split "`r?`n" | Where-Object { $_ -and ($_ -notmatch '^\s*#') })) { $lines += ('  - ' + $_.Trim()) }
          $lines += ''
          $lines += ('- Branch-specific docs (if present): ' + $branchDocUrl)
          $lines += ('- Default docs: ' + $docsUrl)
          $lines += ('- Settings: ' + $settingsUrl)
          $lines += ''
          $lines += '- To enforce this gate:'
          $lines += '  1) Add an admin PAT as repository secret `XCLI_PAT`.'
          $lines += '  2) Ensure branch protection rules include the required checks above.'
          $lines += '  3) Re-run the workflow.'
          $text = $lines -join "`n"
          $text | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          # Also print to console for quick visibility
          Write-Host $text
        }
        $expected = @()
        $text = $env:REQUIRED_CHECKS -split "`r?`n" | Where-Object { $_ -and ($_ -notmatch '^\s*#') }
        foreach ($ln in $text) { $expected += ($ln.Trim()) }
        if (-not $ok) {
          # If strict and fail-on-no-access, fail; otherwise allow CI to proceed with notice-only.
          if ($env:STRICT -eq 'true' -and $env:FAIL_NO_ACCESS -eq 'true') {
            Write-Host '::error::Branch protection could not be read. Failing fast per strict gate policy.'
            exit 21
          } else {
            exit 0
          }
        }
        # GitHub may return legacy contexts or structured checks; support both
        $live = @()
        if ($json.contexts) { foreach ($c in $json.contexts) { $live += [string]$c } }
        if ($json.checks)   { foreach ($c in $json.checks)   { if ($c.context) { $live += [string]$c.context } } }
        # If empty, try Repository Rulesets API as best-effort fallback
        if (-not $live -or $live.Count -eq 0) {
          try {
            $rulesUrl = "https://api.github.com/repos/$owner/$name/rulesets?target=branch&ref_name=$branch"
            $rules = Invoke-RestMethod -Method Get -Uri $rulesUrl -Headers $hdr -ErrorAction Stop
            if ($rules) {
              foreach ($rs in $rules) {
                if ($rs.rules) {
                  foreach ($r in $rs.rules) {
                    if ($r.type -and ($r.type -match 'required_status_checks')) {
                      $p = $r.parameters
                      if ($p) {
                        # Attempt to read common shapes
                        if ($p.required_status_checks) { foreach ($ctx in $p.required_status_checks) { if ($ctx.context) { $live += [string]$ctx.context } elseif ($ctx.name) { $live += [string]$ctx.name } elseif ([string]::IsNullOrEmpty($ctx) -eq $false) { $live += [string]$ctx } } }
                        elseif ($p.checks) { foreach ($ctx in $p.checks) { if ($ctx.context) { $live += [string]$ctx.context } elseif ($ctx.name) { $live += [string]$ctx.name } elseif ([string]::IsNullOrEmpty($ctx) -eq $false) { $live += [string]$ctx } } }
                        elseif ($p.contexts) { foreach ($ctx in $p.contexts) { if ([string]::IsNullOrEmpty($ctx) -eq $false) { $live += [string]$ctx } } }
                      }
                    }
                  }
                }
              }
            }
          } catch { }
        }
        $live = $live | Sort-Object -Unique
        $expSet = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
        foreach ($e in $expected) { [void]$expSet.Add($e) }
        $liveSet = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
        foreach ($l in $live) { [void]$liveSet.Add($l) }
        $missing = @(); foreach ($e in $expSet) { if (-not $liveSet.Contains($e)) { $missing += $e } }
        $extra   = @(); foreach ($l in $liveSet) { if (-not $expSet.Contains($l)) { $extra   += $l } }
        $lines = @('### Branch Protection Gate','')
        $lines += "- Repo: $repo  Branch: $branch"
        $lines += "- Expected: " + ($expected -join ', ')
        $lines += "- Live: " + ($live -join ', ')
        if ($missing.Count -gt 0) { $lines += ('- Missing: ' + ($missing -join ', ')) } else { $lines += '- Missing: (none)' }
        if ($extra.Count   -gt 0) { $lines += ('- Extra: ' + ($extra -join ', ')) } else { $lines += '- Extra: (none)' }
        $lines -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
        if ($missing.Count -gt 0 -and $env:STRICT -eq 'true') {
          Write-Host '::error::Branch protection missing required checks. See summary.'
          exit 21
        }
        exit 0
