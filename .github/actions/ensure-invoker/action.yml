name: ensure-invoker
description: Start/stop a one-shot invoker per job with sentinel/markers
inputs:
  mode:
    description: start or stop
    required: true
  results-dir:
    description: Base results directory
    required: false
    default: tests/results
  category:
    description: Optional category subfolder appended to results-dir
    required: false
  timeout-seconds:
    description: Wait time for ready/stop markers
    required: false
    default: '60'
  retries:
    description: Attempts to (re)start if not ready
    required: false
    default: '3'
  retry-delay-seconds:
    description: Delay between retries
    required: false
    default: '7'
outputs:
  pipe-name:
    description: Computed pipe name for this job
    value: ${{ steps.compute.outputs.pipe_name }}
  sentinel-path:
    description: Sentinel path for this job
    value: ${{ steps.compute.outputs.sentinel }}
  ready:
    description: "'true' if invoker reached READY"
    value: ${{ steps.start.outputs.ready }}
  reason:
    description: "Reason when not ready (timeout|error|ready)"
    value: ${{ steps.start.outputs.reason }}
runs:
  using: composite
  steps:
    - id: compute
      shell: pwsh
      run: |
        $base = '${{ inputs.results-dir }}'
        $cat  = '${{ inputs.category }}'
        if ($cat) { $base = Join-Path $base $cat }
        $pipe = "lvci.invoker.$env:GITHUB_RUN_ID.$env:GITHUB_JOB.$env:GITHUB_RUN_ATTEMPT"
        $sent = Join-Path $env:RUNNER_TEMP "invoker/$($env:GITHUB_RUN_ID).$($env:GITHUB_JOB).sentinel"
        New-Item -ItemType Directory -Path (Split-Path -Parent $sent) -Force | Out-Null
        "pipe_name=$pipe" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "sentinel=$sent"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "results=$base"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

    - name: Start invoker (Windows only)
      id: start
      if: ${{ inputs.mode == 'start' && runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $results = '${{ steps.compute.outputs.results }}'
        if (-not (Test-Path -LiteralPath $results)) { New-Item -ItemType Directory -Path $results -Force | Out-Null }
        $invdir  = Join-Path $results '_invoker'
        if (-not (Test-Path -LiteralPath $invdir)) { New-Item -ItemType Directory -Path $invdir -Force | Out-Null }
        $pipe    = '${{ steps.compute.outputs.pipe_name }}'
        $sent    = '${{ steps.compute.outputs.sentinel }}'
        $ready   = Join-Path $results '_invoker/ready.json'
        $stopped = Join-Path $results '_invoker/stopped.json'
        $boot    = Join-Path $results '_invoker/boot.log'
        if (Test-Path -LiteralPath $ready) { Remove-Item -LiteralPath $ready -Force -ErrorAction SilentlyContinue }
        if (Test-Path -LiteralPath $stopped) { Remove-Item -LiteralPath $stopped -Force -ErrorAction SilentlyContinue }
        if (-not (Test-Path -LiteralPath $sent)) { New-Item -ItemType File -Path $sent -Force | Out-Null }
        $attempts = [int]'${{ inputs.retries }}'
        $delay    = [int]'${{ inputs.retry-delay-seconds }}'
        $to       = [int]'${{ inputs.timeout-seconds }}'
        $ok = $false; $err=''
        # Resolve PowerShell 7 executable explicitly (service context may lack PATH)
        $psExe = $null
        try { $cmd = Get-Command pwsh -ErrorAction SilentlyContinue; if ($cmd -and $cmd.Source) { $psExe = $cmd.Source } } catch {}
        if (-not $psExe -and $PSHome) { $psExe = Join-Path $PSHome 'pwsh.exe' }
        if (-not (Test-Path -LiteralPath $psExe -PathType Leaf)) { $psExe = 'pwsh' }

        for ($i=1; $i -le $attempts; $i++) {
          $ts = (Get-Date -Format o)
          try {
            $args = @('-ExecutionPolicy','Bypass','-NoLogo','-NoProfile','-File','tools/RunnerInvoker/Start-RunnerInvoker.ps1','-PipeName',"$pipe",'-SentinelPath',"$sent",'-ResultsDir',"$results")
            $envMap = @{}
            foreach ($k in @('LV_NOTICE_DIR','LV_SUPPRESS_UI','LV_NO_ACTIVATE','LV_CURSOR_RESTORE','LV_IDLE_WAIT_SECONDS','LV_IDLE_MAX_WAIT_SECONDS')) {
              $v = [Environment]::GetEnvironmentVariable($k)
              if ($v -and $v -ne '') { $envMap[$k] = $v }
            }
            $wd = if ($env:GITHUB_WORKSPACE) { $env:GITHUB_WORKSPACE } else { (Get-Location).Path }
            $p = Start-Process -FilePath $psExe -ArgumentList $args -WindowStyle Hidden -PassThru -WorkingDirectory $wd -Environment $envMap
            Write-Host "Started invoker attempt #$i pid=$($p.Id) pipe=$pipe"
            "[$ts] attempt#$i spawn pid=$($p.Id) pipe=$pipe" | Out-File -FilePath $boot -Append -Encoding utf8
          } catch {
            $err = $_.Exception.Message
            Write-Host "::warning::Failed to spawn invoker on attempt #${i}: ${err}"
            "[$ts] attempt#$i spawn error: $err" | Out-File -FilePath $boot -Append -Encoding utf8
          }
          $sw = [Diagnostics.Stopwatch]::StartNew()
          while ($sw.Elapsed.TotalSeconds -lt $to) { if (Test-Path -LiteralPath $ready) { $ok = $true; break }; Start-Sleep -Milliseconds 300 }
          if ($ok) { "[$(Get-Date -Format o)] attempt#$i ready observed" | Out-File -FilePath $boot -Append -Encoding utf8; break }
          if ($i -lt $attempts) {
            try { if ($p -and -not $p.HasExited) { $p | Stop-Process -Force -ErrorAction SilentlyContinue } } catch {}
            "[$(Get-Date -Format o)] attempt#$i timed out after $to s; retrying in $delay s" | Out-File -FilePath $boot -Append -Encoding utf8
            Start-Sleep -Seconds $delay
          }
        }
        if ($ok) {
          "ready=true"  | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "reason=ready"| Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        } else {
          "[$(Get-Date -Format o)] all attempts exhausted; lastError=$err" | Out-File -FilePath $boot -Append -Encoding utf8
          Write-Host "::error::Invoker not ready after ${to} s (attempts=$attempts). LastError=${err}"
          "ready=false"        | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "reason=timeout"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          exit 1
        }

    - name: Invoker ping (Windows only)
      if: ${{ inputs.mode == 'start' && runner.os == 'Windows' && steps.start.outputs.ready == 'true' }}
      shell: pwsh
      run: |
        $args = @(
          '-PipeName','${{ steps.compute.outputs.pipe_name }}',
          '-ResultsDir','${{ steps.compute.outputs.results }}',
          '-TimeoutSeconds','15',
          '-Retries','5',
          '-RetryDelaySeconds','2'
        )
        pwsh -File tools/RunnerInvoker/Wait-InvokerReady.ps1 @args

    - name: Stop invoker (Windows only)
      if: ${{ inputs.mode == 'stop' && runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $results = '${{ steps.compute.outputs.results }}'
        $sent    = '${{ steps.compute.outputs.sentinel }}'
        $stopped = Join-Path $results '_invoker/stopped.json'
        if (Test-Path -LiteralPath $sent) { Remove-Item -LiteralPath $sent -Force -ErrorAction SilentlyContinue }
        $to = [int]'${{ inputs.timeout-seconds }}'
        $sw = [Diagnostics.Stopwatch]::StartNew()
        while ($sw.Elapsed.TotalSeconds -lt $to) { if (Test-Path -LiteralPath $stopped) { break }; Start-Sleep -Milliseconds 300 }
        if (-not (Test-Path -LiteralPath $stopped)) { Write-Host "::warning::Invoker stop marker not observed within ${to} s (continuing)" }

    - name: No-op on non-Windows
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: echo ensure-invoker non-Windows runner, skipping
